# 全面覆盖js核心知识点



js考察的几大核心知识

- 原型、原型链
- 作用域
- 闭包
- this
- 继承
- Ajax
- ES6



[TOC]



## 下面代码的运行结果分别是什么？`作用域`,`ES6-let`

```javascript
for (let i=0;i<3;i++){
    setTimeout(function (){
        console.log(i);
    },0)
}


for (var i=0;i<3;i++){
    setTimeout(function (){
        console.log(i);
    },0)
}
// 3,3,3
```

上面代码输出的结果分别是：

- 0,1,2
- 3,3,3

原因分析：

let 可以创建词法作用域, 但是var不行.
词法作用域是指作用域是在写代码或者说定义的时候决定的, 而不是在运行的时候决定的.
词法作用域是静态作用域, 而动态作用域是在运行的时候决定的.



扩展问题：

- let还有哪些特性与优势？
- 如果还是使用var定义变量，要怎么改写这段代码才能正常运行？`闭包`





## 下面代码运行结果是什么? `ES6-let`

下面的代码运行中浏览器中

```javascript
 var value=11; 
 let value2=22; 

window.value=111; 
window.value2=222;

console.log(value); 
console.log(value2); 
```

代码输出结果是：

```
111
22
```

结果分析：

 在全局环境中，使用var定义的变量会挂载在全局对象上，浏览器的中全局对象就是window. 所以window修改全局对象的属性会影响到全局变量value的值。

而let定义的变量不会挂载在window全局对象上，所以修改了window.value2的值不会影响到全局变量value2的值。



## 下面代码运行结果是什么？ `this指向`，`箭头函数与普通的区别`

下面的代码运行在浏览器中

```javascript
var name ='global';
const obj = {
  name: 'xiaoming',
  sayName: function () {
    console.log(this.name);
  },
  sayName2: ()=> {
    console.log(this.name);
  }
}

obj.sayName(); 
obj.sayName2();
```

回答：

代码输出结果是：

```
xiaoming
global
```

- obj.sayName()中 sayName中的this指向的是obj对象本身，所以this.name就是 xiaoming;
- obj.sayName2();中由于sayName2使用了箭头函数，箭头函数

 此时的this无法判断指向哪里，只有当运行时才知道。可能指向obj，也可能指向window.主要看调用方式，如果是   obj.sayName()，则指向obj，如果是sayName()，则指向window。
 但是，如果使用了箭头函数，则this指向window



扩展问题：

- 箭头函数和普通函数还有什么区别？
- 如何判断this的指向，有哪几种方式?
- 如何改变this的指向？
- call ,apply, bind有什么区别？

