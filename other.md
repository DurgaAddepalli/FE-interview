### 其他





[TOC]





### 单点登录如何实现？

定义：将多个子系统的认证体系打通，实现了一个入口多处使用

实现方案：

一、共享session



二、基于OpenId



三、基于Cookie的openId存储方案



四、B/S多域名环境下 的单点登陆处理



参考资料[：面试必问的4种单点登录的实现方式，你知道几个？](https://www.bilibili.com/read/cv3668388/)





### node开发的一些小工具，应用？

- 把打包后的资源上传到cdn
- 爬虫开发
- 定制cli





### pm2有什么用？

pm2是一个进程管理工具；

带有负载均衡功能的node应用进程管理器；

pm2管理node服务的优点：

- 自带负载均衡
- 程序崩溃自动重启
- 支持性能监测
- 程序崩溃自动重启



### 文件如何做断点续传？

主要分为三步：

1. 保存文件唯一性标识（通过let md5code=md5(file)）
2. 切割文件；html5的新特性,使用slice方法分割；
3. 分段上传，每次上传一段，根据唯一性标识判断上传进度；

主要思路是把一个大的文件拆分成几个小的文件，分批上传；

如果中断了，从本地存储里面判断已经上传到第几个了，

如果所有文件都上传完了，后台再把文件合并存入数据库中；







### 通过什么做到并发请求？

event loop 事件轮询，setTimeout, 异步请求（ajax,资源加载）





### 什么service worker？

sevice worker 本质是充当web应用程序和浏览器之间的代理，也可在网络可用的情况下作为浏览器和网络间的代理；

用户在离线的情况下，也能通过缓存访问网页

拦截并修改访问的资源和请求，细粒度的缓存资源 ；

主要有以下特性：

1. 只支持https服务，在firefox隐藏模式下 service worker不可用；
2. 消息推送；
3. 后台同步，启动一个serive worker 即使没有用户访问特定站点，也可以更缓存 ；
4. 性能增强，预读取资源





### cookies和session有什么区别？

cookies和session都是做本地存储的；

区别如下：

- cookies存放在客户端，session存放在服务端；
- session默认存在服务器的一个文件中，而不是内存中；
- session一般需要一个session_id,来查找相关数据，session_id一般通地客户端中的cookies和url中取值；



### 你对AST了解多少？

AST是抽象语法树，用来描述源代理的树形结构，类似html中dom;

展现形式看起来像一个对象； 

使用场景：

1. webpack的babel代码转换：es6/7 => es5；

浏览器会把js代码转换成抽象语法树，再转换成字节码或者直接生成机器码；





## 安全





### XSS跨站脚本攻击（Cross-Site Scripting）？

> **跨站脚本攻击，是代码注入的一种方式，它允许恶意用户将代码注入到网页上，其他用户在浏览网页时，就会受到影响**



**分类（按攻击来源）：**

**一、存储型**（存在数据库中）

攻击步骤

1. 【提交恶意代码】：将恶意代码提交到目标网站的数据库中, 比如：发帖，评论，私信，web聊天框

2. 【请求恶意代码】：用户打开网页，服务端取出恶意代码，拼接在HTML中并返回给浏览器

3. 【浏览器解析恶意代码】：浏览器下载完成后，开始解析

4. 【执行恶意代码】：窃取用户数据（用户账号密码），冒充用户行为调用目标网站接口执行攻击者指定操作（转账，清空数据库）



**二、反射型**（恶意代码存在URL中）

统计步骤过程如存储型，只是恶意代码的存储位置不一样，比如：网站搜索，跳转

- 【提交恶意代码】在url上，后端获取到url的script标签做为参数，拼接在页面上返回给页面
- 【浏览器请求/解析/执行 恶意代码】game over

eg:

> http://xxx/search?keyword="><script>alert('XSS');</script>



**三、DOM型：**

DOM型XSS攻击和前两种的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器完成(react,vue中的模板渲染引擎已经内置了处理DOM XSS攻击的措施)，属于前端JS自身的安全漏洞。而其他两种XSS属于服务端的安全漏洞（服务端要做转义后渲染输入，拼接html）



**解决方案**

一、**预防存储型和反射型攻击**

- 【对HTML做充分转义】：比如常用的模板引擎内置转义器：ejs，但是这种模板引擎并不完善，要完善XSS防护措施，需要更完善的更细致的转义策略
- 【纯前端渲染】，把代码和数据分隔开

二、**预防DOM弄XSS攻击**

- 【DOM操作方法选择】在使用InnerHTML,outerHTML,document.write时要特点小心，不要把不可信的数据作为html插入到页面中，尽量使用 .textContent, .setAttribut()等
- 【VUE/React技术栈】：尽量不使用 v-html/dangerouslySetInnerHTML功能，就在前端render阶段避免innerHTML,outerHTML的 XSS隐患
- DOM中的内联事件监听器，如: location/onclick/onerror/onload/onmouseover等，＜ａ＞标签的ｈｒｅｆ属性，ｊｓ中的　ｅｖａｌ、ｓｅｔｔｉｍｅｏｕｔ等，都能把字符串作为代码运行

其他方案

- 【HTTP-only Cookie】: 禁止js读取某些敏感cookie,攻击都完成XSS注入后无法窃取此Cookie
- 【验证码】：防止脚本冒充用户提交危险操作（删除全部，转账）





### CSRF跨站请求伪造攻击？

CSRF（Cross-site request forgery）：攻击者诱导用户进入第三方网站，向被攻击的网站发送跨站请求。利用用户在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站某项操作的目的；

**CSRF攻击流程：**

- 用户在A网站登录了
- 诱导用户访问B网站
- B网站向A发送一个请求 ( a.com/act=xx )，浏览器会默认携带 A网站 的cookie 
- A网站收到请求后，对请求进行验证，确认是用户的凭证，误以为是用户发送的请求
- A网站以用户的名义执行了 act=xx的命令
- 攻击完成



**CSRF分类：**

- GET类型：一个url地址，可以是一张图片，自动发送； eg: <img src=http://wooyun.org/csrf.php?xx=11 /> 
- POST类型：js自动提交表单的形式，只在诱导网站提交，危害比GET小
- 链接类型的：a标签链接，触发条件要用户点击才可以，eg: 恶意图片，广告形式的链接



**CSRF特点及预防手段**

特点：

- CSRF（通常）发生在第三方域名
- CSRF攻击者不能获取到Cookie 等信息，只能使用

预防：

- 阻止不明外域的访问
- - 同源检查（请求头header相关字段,判断来源域名）：
    - origin 
    - referer
  - Samesite Cookie
- 提交时要求附加本域才能获取的信息
- - CSRF Token
  - 双重Cookie验证





### HTTP header 中 host, referer, origin区别？









### 项目中如何处理安全问题？

- XSS跨站脚本攻击：数据转

- CSRF跨站请求伪造攻击token认证

- 开启https，避免数据劫持/监听
- cookis设置path来限制防问的域名范围，开启secure
- iframe滥用：iframe内容由第三方提供，默认情况下不受控制，他们可以在iframe中运行javascript脚本，带来一定安全问题
- 恶意第三方库

比如对抗 XSS/CSRF 的策略，账号风控策略、图片安全策略、恶意内容对抗策略、等等

跨站请求伪造：通过get请求进行数据操作，



## 数据库



### mysql，mongodb 区别？



|            | Mongodb                              | Mysql                                     |
| ---------- | ------------------------------------ | ----------------------------------------- |
| 数据库模型 | 非关系型 （NoSql）                   | 关系型                                    |
| 存储方式   | 虚假内存+持久化（速度快）            | 不同的引擎有不同的存储方式                |
| 查询语句   | 独特的Mongodb查询方式                | 传统sql语句                               |
| 架构特点   | 可以通过副本集，以及分片来实现高可用 | 常用有单点，M-S,MHA,MMM,Cluster等架构方式 |
| 使用场景   | 文档                                 | all                                       |



**一、mysql**

> 关系型数据库

优点

- 不同引擎上有不同存储方式

缺点：

- 海量数据处理慢



**二、mongodb**

> 基于分布式文件存储的开源数据系统

优点：

- 【快速】内存级存储，它将热数据存储在物理内存中（而不仅仅是索引和少部分数据）
- 【高扩展性】集群架构，可通过物理机的增加提高扩展性
- 【自身的failover机制】当主库遇到问题，副本集将选举出一个新的主库来继续提供服务
- 【json 的存储格式】适合文档格式的存储与查询

缺点：

- 不支持事务

- 占用空间大

- 无法进行关联操作

- 复杂聚合操作能过MapRReduce创建，速度慢

  





### redis持久化缓存？

**一、RDB持久化**

> 将redis内存中的数据定时 dump（倾倒） 到磁盘中

- redis fork一个子进程，先将数据写入临时文件
- 写入成功后，再替换之前的文件,用二进制压缩存储

优点：

- 【管理性强】：整个redis数据库最终备份成一个文件（方便管理，还原，压缩，转储）
- 【对服务影响最小】唯一要做的就是fork出子进程，之后的持久化工作由子进程处理
- 【启动效率高】记录的是源数据，而非数据操作

缺点：

- 【低可靠性】数据可用性得不到保障（定时写入的，可能数据还没同步就宕机了）
- 【大数据暂停服务】数据量大的情况下，fork子进程的操作可能会使服用短暂停止（通常几百毫秒）



![img](https://upload-images.jianshu.io/upload_images/5704547-5e806f4d62e9927d.png!web?imageMogr2/auto-orient/strip|imageView2/2/w/520/format/webp)

**二、AOF持久化**

> 将redis的操作日志以文件追加的方式写入文件，只记录写、删除操作、查询操作不会记录（类似mySQL的Binlog日志）



![img](https://upload-images.jianshu.io/upload_images/5704547-bc1e973bc681081c.png!web?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

优点：

- 【高可用】实时同步

缺点：

- 【体积较大】
- 【恢复数据慢】RDB省去了执行的步骤，直接导入源数据



缺点：







### redis介绍？

>  高性能的key-value数据

一、**redis特点：**

redis 收不到其他 key-value数据缓存产品有以下三个特点：

- 默认数据存储在内存中，也可将内容内存中的数据保存在池盘中，做到持久化，重启时可再次加载
- 不仅仅支持简单的 key-value 类型的数据，同时提供多种数据结构
- 支持数据的备份，即master-slave模式的数据备份

**redis支持的数据结构：**

- String 字符串型
- Hash 散列
- List 列表
- Set 集合
- Sorted Set 有序集合







## Git



### git merge 与 git rebase区别?





### git pull 与 git fetch区别？





