### 其他





[TOC]



### 单点登录如何实现？

定义：将多个子系统的认证体系打通，实现了一个入口多处使用

实现方案：

一、共享session



二、基于OpenId



三、基于Cookie的openId存储方案



四、B/S多域名环境下 的单点登陆处理



参考资料[：面试必问的4种单点登录的实现方式，你知道几个？](https://www.bilibili.com/read/cv3668388/)





### node开发的一些小工具，应用？

- 把打包后的资源上传到cdn
- 爬虫开发
- 定制cli





### pm2有什么用？

pm2是一个进程管理工具；

带有负载均衡功能的node应用进程管理器；

pm2管理node服务的优点：

- 自带负载均衡
- 程序崩溃自动重启
- 支持性能监测
- 程序崩溃自动重启



### 文件如何做断点续传？

主要分为三步：

1. 保存文件唯一性标识（通过let md5code=md5(file)）
2. 切割文件；html5的新特性,使用slice方法分割；
3. 分段上传，每次上传一段，根据唯一性标识判断上传进度；

主要思路是把一个大的文件拆分成几个小的文件，分批上传；

如果中断了，从本地存储里面判断已经上传到第几个了，

如果所有文件都上传完了，后台再把文件合并存入数据库中；







### 通过什么做到并发请求？

event loop 事件轮询，setTimeout, 异步请求（ajax,资源加载）





### 什么service worker？

sevice worker 本质是充当web应用程序和浏览器之间的代理，也可在网络可用的情况下作为浏览器和网络间的代理；

用户在离线的情况下，也能通过缓存访问网页

拦截并修改访问的资源和请求，细粒度的缓存资源 ；

主要有以下特性：

1. 只支持https服务，在firefox隐藏模式下 service worker不可用；
2. 消息推送；
3. 后台同步，启动一个serive worker 即使没有用户访问特定站点，也可以更缓存 ；
4. 性能增强，预读取资源





### cookies和session有什么区别？

cookies和session都是做本地存储的；

区别如下：

- cookies存放在客户端，session存放在服务端；
- session默认存在服务器的一个文件中，而不是内存中；
- session一般需要一个session_id,来查找相关数据，session_id一般通地客户端中的cookies和url中取值；



### 你对AST了解多少？

AST是抽象语法树，用来描述源代理的树形结构，类似html中dom;

展现形式看起来像一个对象； 

使用场景：

1. webpack的babel代码转换：es6/7 => es5；

浏览器会把js代码转换成抽象语法树，再转换成字节码或者直接生成机器码；





## 安全





### XSS跨站脚本攻击（Cross-Site Scripting）？

> **跨站脚本攻击，是代码注入的一种方式，它允许恶意用户将代码注入到网页上，其他用户在浏览网页时，就会受到影响**



**分类（按攻击来源）：**

**一、存储型**（存在数据库中）

攻击步骤

1. 【提交恶意代码】：将恶意代码提交到目标网站的数据库中, 比如：发帖，评论，私信，web聊天框

2. 【请求恶意代码】：用户打开网页，服务端取出恶意代码，拼接在HTML中并返回给浏览器

3. 【浏览器解析恶意代码】：浏览器下载完成后，开始解析

4. 【执行恶意代码】：窃取用户数据（用户账号密码），冒充用户行为调用目标网站接口执行攻击者指定操作（转账，清空数据库）



**二、反射型**（恶意代码存在URL中）

统计步骤过程如存储型，只是恶意代码的存储位置不一样，比如：网站搜索，跳转

- 【提交恶意代码】在url上，后端获取到url的script标签做为参数，拼接在页面上返回给页面
- 【浏览器请求/解析/执行 恶意代码】game over

eg:

> http://xxx/search?keyword="><script>alert('XSS');</script>



**三、DOM型：**

DOM型XSS攻击和前两种的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器完成(react,vue中的模板渲染引擎已经内置了处理DOM XSS攻击的措施)，属于前端JS自身的安全漏洞。而其他两种XSS属于服务端的安全漏洞（服务端要做转义后渲染输入，拼接html）



**解决方案**

一、**预防存储型和反射型攻击**

- 【对HTML做充分转义】：比如常用的模板引擎内置转义器：ejs，但是这种模板引擎并不完善，要完善XSS防护措施，需要更完善的更细致的转义策略
- 【纯前端渲染】，把代码和数据分隔开

二、**预防DOM弄XSS攻击**

- 【DOM操作方法选择】在使用InnerHTML,outerHTML,document.write时要特点小心，不要把不可信的数据作为html插入到页面中，尽量使用 .textContent, .setAttribut()等
- 【VUE/React技术栈】：尽量不使用 v-html/dangerouslySetInnerHTML功能，就在前端render阶段避免innerHTML,outerHTML的 XSS隐患
- DOM中的内联事件监听器，如: location/onclick/onerror/onload/onmouseover等，＜ａ＞标签的ｈｒｅｆ属性，ｊｓ中的　ｅｖａｌ、ｓｅｔｔｉｍｅｏｕｔ等，都能把字符串作为代码运行

其他方案

- 【HTTP-only Cookie】: 禁止js读取某些敏感cookie,攻击都完成XSS注入后无法窃取此Cookie
- 【验证码】：防止脚本冒充用户提交危险操作（删除全部，转账）





### CSRF跨站请求伪造攻击？

CSRF（Cross-site request forgery）：攻击者诱导用户进入第三方网站，向被攻击的网站发送跨站请求。利用用户在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站某项操作的目的；

**CSRF攻击流程：**

- 用户在A网站登录了
- 诱导用户访问B网站
- B网站向A发送一个请求 ( a.com/act=xx )，浏览器会默认携带 A网站 的cookie 
- A网站收到请求后，对请求进行验证，确认是用户的凭证，误以为是用户发送的请求
- A网站以用户的名义执行了 act=xx的命令
- 攻击完成



**CSRF分类：**

- GET类型：一个url地址，可以是一张图片，自动发送； eg: <img src=http://wooyun.org/csrf.php?xx=11 /> 
- POST类型：js自动提交表单的形式，只在诱导网站提交，危害比GET小
- 链接类型的：a标签链接，触发条件要用户点击才可以，eg: 恶意图片，广告形式的链接



**CSRF预防**

- 阻止不明外域的访问
- - 同源检查
  - Samesite Cookie
- 





### 项目中如何处理安全问题？

- XSS跨站脚本攻击：数据转

- CSRF跨站请求伪造攻击token认证

- 开启https，避免数据劫持/监听
- cookis设置path来限制防问的域名范围，开启secure
- iframe滥用：iframe内容由第三方提供，默认情况下不受控制，他们可以在iframe中运行javascript脚本，带来一定安全问题
- 恶意第三方库

比如对抗 XSS/CSRF 的策略，账号风控策略、图片安全策略、恶意内容对抗策略、等等

跨站请求伪造：通过get请求进行数据操作，







